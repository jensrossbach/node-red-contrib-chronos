<!--
Copyright (c) 2024 Jens-Uwe Rossbach

This code is licensed under the MIT License.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->

<script type="text/html" data-template-name="chronos-delay">
    <div class="form-row">
        <label for="node-input-name"><i class="fa fa-tag"></i> <span data-i18n="node-red-contrib-chronos/chronos-config:common.label.name"></span></label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]node-red-contrib-chronos/chronos-config:common.label.name">
    </div>
    <div class="form-row">
        <label for="node-input-config"><i class="fa fa-cog"></i> <span data-i18n="node-red-contrib-chronos/chronos-config:common.label.config"></span></label>
        <input type="text" id="node-input-config" data-i18n="[placeholder]node-red-contrib-chronos/chronos-config:common.label.config">
    </div>
    <div class="form-row" style="padding-top: 4px;">
        <label for="node-input-delayType"><i class="fa fa-sliders"></i> <span data-i18n="delay.label.delayType"></span></label>
        <select id="node-input-delayType" style="width: auto;">
            <option value="fixedDuration" data-i18n="delay.list.delayType.fixedDuration"></option>
            <option value="randomDuration" data-i18n="delay.list.delayType.randomDuration"></option>
            <option value="pointInTime" data-i18n="delay.list.delayType.pointInTime"></option>
            <option value="custom" data-i18n="delay.list.delayType.custom"></option>
        </select>
    </div>
    <div id="form-row-fixedDuration" class="form-row">
        <label for="node-input-fixedDuration"><i class="fa fa-hourglass-end"></i> <span data-i18n="delay.label.duration"></span></label>
        <input id="node-input-fixedDuration" style="width: 50px !important; float: left;" value="1">
        <select id="node-input-fixedDurationUnit" style="margin-left: 4px; width: auto;">
            <option value="milliseconds" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.milliseconds"></option>
            <option value="seconds" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.seconds"></option>
            <option value="minutes" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.minutes"></option>
            <option value="hours" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.hours"></option>
            <option value="days" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.days"></option>
        </select>
    </div>
    <div id="form-row-randomDuration" class="form-row">
        <label for="node-input-randomDuration1"><i class="fa fa-hourglass-end"></i> <span data-i18n="delay.label.duration"></span></label>
        <input id="node-input-randomDuration1" style="width: 50px !important; float: left;" value="1">
        &nbsp;<span>-</span>&nbsp;
        <input id="node-input-randomDuration2" style="width: 50px !important; float: left;" value="1">
        <select id="node-input-randomDurationUnit" style="margin-left: 4px; width: auto;">
            <option value="milliseconds" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.milliseconds"></option>
            <option value="seconds" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.seconds"></option>
            <option value="minutes" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.minutes"></option>
            <option value="hours" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.hours"></option>
            <option value="days" data-i18n="node-red-contrib-chronos/chronos-config:common.list.unit.days"></option>
        </select>
    </div>
    <div id="form-row-randomizerGranularity" class="form-row">
        <input id="node-input-randomizerMillis" type="checkbox" style="margin-left: 104px; margin-top: 0px; margin-bottom: 1px; width: auto;">
        <label for="node-input-randomizerMillis" style="margin-bottom: 0px; width: auto;" data-i18n="delay.label.randomizerMillis"></label>
    </div>
    <div id="form-row-when" class="form-row">
        <label for="node-input-when"><i class="fa fa-clock-o"></i> <span data-i18n="delay.label.when"></span></label>
        <input type="text" id="node-input-when" style="width: 70%;">
        <input id="node-input-whenType" type="hidden">
        <input id="node-input-whenValue" type="hidden">
    </div>
    <div id="form-row-offset" class="form-row">
        <label for="node-input-offset"><i class="fa fa-arrows-h"></i> <span data-i18n="node-red-contrib-chronos/chronos-config:common.label.offset"></span></label>
        <input id="node-input-offset" style="width: 60px !important;">
        <span style="padding-left: 10px;">
            <input id="node-input-random" type="checkbox" style="width: auto; margin-top: 0px; margin-bottom: 1px;">
            <label for="node-input-random" style="width: auto; margin-bottom: 0px;" data-i18n="node-red-contrib-chronos/chronos-config:common.label.random"></label>
        </span>
    </div>
    <div id="form-row-custom" class="form-row">
        <label for="node-input-customDelay"><i class="fa fa-hourglass-end"></i> <span data-i18n="delay.label.delay"></span></label>
        <input type="text" id="node-input-customDelay" style="width: 70%;">
        <input id="node-input-customDelayType" type="hidden">
        <input id="node-input-customDelayValue" type="hidden">
    </div>
    <div class="form-row" style="padding-top: 10px">
        <input id="node-input-preserveCtrlProps" type="checkbox" style="margin-top: 0px; margin-bottom: 1px; width: auto;">
        <label for="node-input-preserveCtrlProps" style="margin-bottom: 0px; width: auto;" data-i18n="node-red-contrib-chronos/chronos-config:common.label.preserveCtrlProps"></label>
    </div>
    <div class="form-row">
        <input id="node-input-ignoreCtrlProps" type="checkbox" style="margin-top: 0px; margin-bottom: 1px; width: auto;">
        <label for="node-input-ignoreCtrlProps" style="margin-bottom: 0px; width: auto;" data-i18n="node-red-contrib-chronos/chronos-config:common.label.ignoreCtrlProps"></label>
    </div>
</script>

<script type="text/javascript">
    (function()
    {
        const PATTERN_TIME         = /^(?:\d|0\d|1\d|2[0-3]):(?:[0-5]\d)(?::(?:[0-5]\d))?\s*(?:a|am|A|AM|p|pm|P|PM)?$/;
        const PATTERN_CUSTOM_TIME  = /^[a-zA-Z][0-9a-zA-Z_]*$/;

        RED.nodes.registerType("chronos-delay",
        {
            category:     "chronos",
            color:        "#DEB887",
            icon:         "chronos_delay.svg",
            inputs:       1,
            outputs:      1,
            paletteLabel: "delay",
            label: function()
            {
                let label = "";

                if (this.name)
                {
                    label = this.name;
                }
                else
                {
                    if (this.delayType == "fixedDuration")
                    {
                        label = this.fixedDuration + " " + this._("node-red-contrib-chronos/chronos-config:common.list.unit." + this.fixedDurationUnit);
                    }
                    else if (this.delayType == "randomDuration")
                    {
                        if (this.randomDuration1 == this.randomDuration2)
                        {
                            label = this.randomDuration1;
                        }
                        else if (this.randomDuration2 > this.randomDuration1)
                        {
                            label = this.randomDuration1
                                    + " - "
                                    + this.randomDuration2;
                        }
                        else
                        {
                            label = this.randomDuration2
                                    + " - "
                                    + this.randomDuration1;
                        }

                        label += " " + this._("node-red-contrib-chronos/chronos-config:common.list.unit." + this.randomDurationUnit);
                    }
                    else if (this.delayType == "pointInTime")
                    {
                        if (this.whenType && this.whenValue)
                        {
                            if ((this.whenType == "time") || (this.whenType == "custom"))
                            {
                                label = this.whenValue;
                            }
                            else
                            {
                                label = this._("node-red-contrib-chronos/chronos-config:common.list." + this.whenType + "." + this.whenValue);
                            }

                            if (this.offset != 0)
                            {
                                label += ((this.offset > 0) ? " + " : " - ");

                                if (this.random)
                                {
                                    label += "~";
                                }

                                label += Math.abs(this.offset) + " " + this._("node-red-contrib-chronos/chronos-config:common.label.min");
                            }
                        }
                    }
                    else if (this.delayType == "custom")
                    {
                        if (typeof this.expression == "string")  // backward compatibility to v1.18.x and earlier
                        {
                            if (this.expression.length <= 50)
                            {
                                label = this.expression;
                            }
                            else
                            {
                                label = this.expression.substring(0, 49) + "...";
                            }
                        }
                        else if (this.customDelayType == "jsonata")
                        {
                            if (this.customDelayValue.length <= 50)
                            {
                                label = this.customDelayValue;
                            }
                            else
                            {
                                label = this.customDelayValue.substring(0, 49) + "...";
                            }
                        }
                        else if (this.customDelayType == "env")
                        {
                            if (this.customDelayValue.includes("${"))
                            {
                                label = this.customDelayValue;
                            }
                            else
                            {
                                label = "${" + this.customDelayValue + "}";
                            }
                        }
                        else
                        {
                            label = this.customDelayType + "." + this.customDelayValue;
                        }
                    }
                }

                return label || this._("delay.label.node");
            },
            labelStyle: function()
            {
                return (this.name ? "node_label_italic" : "");
            },
            inputLabels: function()
            {
                return this._("node-red-contrib-chronos/chronos-config:common.label.inputPort");
            },
            outputLabels: function(index)
            {
                return this._("delay.label.outputPort");
            },
            defaults:
            {
                name:
                {
                    value: ""
                },
                config:
                {
                    value:    "",
                    type:     "chronos-config",
                    required: true
                },
                delayType:
                {
                    value: "fixedDuration"
                },
                fixedDuration:
                {
                    value:    "1",
                    required: true
                },
                fixedDurationUnit:
                {
                    value: "seconds"
                },
                randomDuration1:
                {
                    value:    "1",
                    required: true
                },
                randomDuration2:
                {
                    value:    "5",
                    required: true
                },
                randomDurationUnit:
                {
                    value: "seconds"
                },
                randomizerMillis:
                {
                    value: false
                },
                whenType:
                {
                    value: "time"
                },
                whenValue:
                {
                    value: "",
                    validate: function(v, opt)
                    {
                        let res = true;

                        if ($("#node-input-delayType").val() == "pointInTime")
                        {
                            const whenType = $("#node-input-when").typedInput("type");

                            if ((whenType == "time") && !PATTERN_TIME.test(v))
                            {
                                res = opt ? this._("node-red-contrib-chronos/chronos-config:common.error.invalidTime") : false;
                            }
                            else if ((whenType == "custom") && !PATTERN_CUSTOM_TIME.test(v))
                            {
                                res = opt ? this._("node-red-contrib-chronos/chronos-config:common.error.invalidName") : false;
                            }
                        }

                        return res;
                    }
                },
                offset:
                {
                    value: "0"
                },
                random:
                {
                    value: false
                },
                customDelayType:
                {
                    value: "jsonata"
                },
                customDelayValue:
                {
                    value: "",
                    validate: function(v, opt)
                    {
                        let res = true;

                        if ($("#node-input-delayType").val() == "custom")
                        {
                            res = RED.utils.validateTypedProperty(v, $("#node-input-customDelay").typedInput("type"), opt);
                        }

                        return res;
                    }
                },
                preserveCtrlProps:
                {
                    value: false
                },
                ignoreCtrlProps:
                {
                    value: false
                }
            },
            oneditprepare: function()
            {
                const node = this;

                const sunTimes =
                [
                    {
                        value: "nightEnd",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.nightEnd")
                    },
                    {
                        value: "nauticalDawn",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.nauticalDawn")
                    },
                    {
                        value: "dawn",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.dawn")
                    },
                    {
                        value: "sunrise",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.sunrise")
                    },
                    {
                        value: "sunriseEnd",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.sunriseEnd")
                    },
                    {
                        value: "goldenHourEnd",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.goldenHourEnd")
                    },
                    {
                        value: "solarNoon",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.solarNoon")
                    },
                    {
                        value: "goldenHour",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.goldenHour")
                    },
                    {
                        value: "sunsetStart",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.sunsetStart")
                    },
                    {
                        value: "sunset",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.sunset")
                    },
                    {
                        value: "dusk",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.dusk")
                    },
                    {
                        value: "nauticalDusk",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.nauticalDusk")
                    },
                    {
                        value: "night",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.night")
                    },
                    {
                        value: "nadir",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.sun.nadir")
                    }
                ];

                const moonTimes =
                [
                    {
                        value: "rise",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.moon.rise")
                    },
                    {
                        value: "set",
                        label: node._("node-red-contrib-chronos/chronos-config:common.list.moon.set")
                    }
                ];

                const timeInput =
                {
                    value: "time",
                    label: node._("node-red-contrib-chronos/chronos-config:common.label.time"),
                    icon: "fa fa-clock-o",
                    hasValue: true,
                    validate: PATTERN_TIME
                };

                const sunTimeInput =
                {
                    value: "sun",
                    label: node._("node-red-contrib-chronos/chronos-config:common.label.sun"),
                    icon: "fa fa-sun-o",
                    options: sunTimes
                };

                const moonTimeInput =
                {
                    value: "moon",
                    label: node._("node-red-contrib-chronos/chronos-config:common.label.moon"),
                    icon: "fa fa-moon-o",
                    options: moonTimes
                };

                const customInput =
                {
                    value: "custom",
                    label: node._("node-red-contrib-chronos/chronos-config:common.label.custom"),
                    icon: "fa fa-user-o",
                    hasValue: true,
                    validate: PATTERN_CUSTOM_TIME
                };

                const validateNumericInput = function(event, ui)
                {
                    const value = parseInt($(this).spinner("value"), 10);
                    const min = $(this).spinner("option", "min");
                    const max = $(this).spinner("option", "max");

                    if (isNaN(value) || (value < min))
                    {
                        $(this).spinner("value", min);
                    }
                    else if (value > max)
                    {
                        $(this).spinner("value", max);
                    }
                };

                const applyLimits = function(elements)
                {
                    let value = $(this).val();
                    switch (value)
                    {
                        case "milliseconds":
                        {
                            for (elem of elements)
                            {
                                elem.spinner("option", "max", 60000);
                            }

                            break;
                        }
                        case "seconds":
                        {
                            for (elem of elements)
                            {
                                elem.spinner("option", "max", 3600);
                            }

                            break;
                        }
                        case "minutes":
                        {
                            for (elem of elements)
                            {
                                elem.spinner("option", "max", 1440);
                            }

                            break;
                        }
                        case "hours":
                        {
                            for (elem of elements)
                            {
                                elem.spinner("option", "max", 168);
                            }

                            break;
                        }
                        case "days":
                        {
                            for (elem of elements)
                            {
                                elem.spinner("option", "max", 7);
                            }

                            break;
                        }
                    }

                    for (elem of elements)
                    {
                        validateNumericInput.call(elem);
                    }
                };

                const fixedDuration =
                        $("#node-input-fixedDuration")
                            .spinner({
                                min: 1,
                                max: 3600,
                                step: 1,
                                change: validateNumericInput});

                const randomDuration1 =
                        $("#node-input-randomDuration1")
                            .spinner({
                                min: 1,
                                max: 3600,
                                step: 1,
                                change: validateNumericInput});

                const randomDuration2 =
                        $("#node-input-randomDuration2")
                            .spinner({
                                min: 1,
                                max: 3600,
                                step: 1,
                                change: validateNumericInput});

                const when =
                        $("#node-input-when")
                            .typedInput({
                                types: [
                                    timeInput,
                                    sunTimeInput,
                                    moonTimeInput,
                                    customInput],
                                typeField: $("#node-input-whenType")});
                when._prevType = "time";

                when.on("change", function()
                {
                    const type = when.typedInput("type");
                    if (type != when._prevType)
                    {
                        when._prevType = type;
                        if ((type != "sun") && (type != "moon"))
                        {
                            when.typedInput("value", "");
                        }
                    }
                });

                const offset =
                        $("#node-input-offset")
                            .spinner({
                                min: -300,
                                max: 300,
                                step: 1,
                                change: validateNumericInput});

                const customDelay =
                        $("#node-input-customDelay")
                            .typedInput({
                                types: [
                                    "jsonata",
                                    "env",
                                    "global",
                                    "flow",
                                    "msg"],
                                typeField: $("#node-input-customDelayType")});
                customDelay._prevType = "jsonata";

                customDelay.on("change", function()
                {
                    const type = customDelay.typedInput("type");
                    if (type != customDelay._prevType)
                    {
                        customDelay._prevType = type;
                        customDelay.typedInput("value", "");
                    }
                });

                $("#node-input-delayType").change(function()
                {
                    $("#form-row-fixedDuration").hide();
                    $("#form-row-randomDuration").hide();
                    $("#form-row-randomizerGranularity").hide();
                    $("#form-row-when").hide();
                    $("#form-row-offset").hide();
                    $("#form-row-custom").hide();

                    const value = $(this).val();
                    switch (value)
                    {
                        case "fixedDuration":
                        {
                            $("#form-row-fixedDuration").show();
                            break;
                        }
                        case "randomDuration":
                        {
                            $("#form-row-randomDuration").show();
                            $("#form-row-randomizerGranularity").show();
                            break;
                        }
                        case "pointInTime":
                        {
                            $("#form-row-when").show();
                            $("#form-row-offset").show();
                            break;
                        }
                        case "custom":
                        {
                            $("#form-row-custom").show();
                            break;
                        }
                    }
                });

                $("#node-input-fixedDurationUnit").change(applyLimits.bind($("#node-input-fixedDurationUnit"), [fixedDuration]));
                $("#node-input-randomDurationUnit").change(applyLimits.bind($("#node-input-randomDurationUnit"), [randomDuration1, randomDuration2]));

                // backward compatibility to v1.17.x and earlier
                if (typeof node.delayType == "undefined")
                {
                    node.delayType = "pointInTime";
                    $("#node-input-delayType").val(node.delayType);

                    node.fixedDuration = "1";
                    $("#node-input-fixedDuration").val(node.fixedDuration);
                    node.fixedDurationUnit = "seconds";
                    $("#node-input-fixedDurationUnit").val(node.fixedDurationUnit);

                    node.randomDuration1 = "1";
                    $("#node-input-randomDuration1").val(node.randomDuration1);
                    node.randomDuration2 = "5";
                    $("#node-input-randomDuration2").val(node.randomDuration2);
                    node.randomDurationUnit = "seconds";
                    $("#node-input-randomDurationUnit").val(node.randomDurationUnit);
                    node.randomizerMillis = false;
                    $("#node-input-randomizerMillis").val(node.randomizerMillis);

                    node.customDelayValue = "";
                    $("#node-input-customDelay").val(node.customDelayValue);
                }

                // backward compatibility to v1.18.x and earlier
                if (typeof node.customDelayType == "undefined")
                {
                    node.customDelayType = "jsonata";
                    $("#node-input-customDelayType").val(node.customDelayType);
                    node.customDelayValue = node.expression;
                    $("#node-input-customDelayValue").val(node.customDelayValue);
                }

                $("#node-input-delayType").change();
                when.typedInput("value", $("#node-input-whenValue").val());
                customDelay.typedInput("value", $("#node-input-customDelayValue").val());
            },
            oneditsave: function()
            {
                $("#node-input-whenValue").val($("#node-input-when").typedInput("value"));
                $("#node-input-customDelayValue").val($("#node-input-customDelay").typedInput("value"));
            }
        });
    })();
</script>
